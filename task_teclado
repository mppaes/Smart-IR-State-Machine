/****************************************************************************
*                                                  São José dos Campos - SP *
*                                                                           *
* Mateus Pinto Paes                                                         *
* ============================================                              *
*                                                                           *
* Programa: HOME-IR                                                         *
* Projeto: HOME-IR                                                          *
* VersãoGit: N/A                                                             *
*                                                                           *
****************************************************************************/
  
/**
* @ingroup task_displaytft
* @brief   Função que exibe nos display tft as informações
* @param   Nenhum
* @return  
 * @return  
 * 
 * @note Verificado por:
* @note Validado por:
*
* @author  Tec. Mateus P Paes (mppaes@me.com)
* @date 06/mai/2015
*
*/

/*********************************************************************
* testdrawtext
*********************************************************************/
void func_hab_recep (int teste)
{
    int botao_n_ok =0;
    long int data_aux;
    long int valor_ir_tv[3];
    int envio = 0;
    int adress_eeprom;
    long int value_erro = 0xFFFFFFFF;


    switch (teste)
			{
				//Controle TV
				case 0:
					//Enquanto nao for Gravado 2 vezes o dado IR fica na funcao
					//teste = 0;
					while (botao_n_ok != 2)
					{
						if (envio == 0)
						{
							lcd.setCursor(0,3);
						//             1234567890123456   
						    lcd.print("Botao ON da TV");
							envio++;
						}
                        else if (envio == 2)
                        {
                            lcd.setCursor(0,3);
						//             1234567890123456   
						    lcd.print("Insira Novamente");
                            envio++;
                        }
                        /*** Habilita Leitura do Receptor IR ***/
    					IRRecv.enableIRIn();
    					delay(500);
						if (IRRecv.decode(&ir_results)) //Verifico se Tem Dado 
					    {
					        	//Verifica se Dado é Valido, Se For Grava dado na var valor_ir_tv
					        	if (ir_results.value != value_erro) 
					        	{
							        valor_ir_tv[botao_n_ok] = ir_results.value;
							        envio++;
							        //Verifica se ja foi Gravado alguma tecla caso nao Apenas icrementa botao_n_ok e pega proximo dado
							        if(botao_n_ok > 0)// Se ja tiver dado gravado entra no if 
							        {
								        //Verifica se dado gravado é igual ao Anterior 
								        if ((valor_ir_tv[botao_n_ok]) == (valor_ir_tv[botao_n_ok - 1]))
								        {									        
			                                if (botao_n_ok == 1)
			                                {
			                                    lcd.setCursor(0,4);
			   								    //         1234567890123456   
						    					lcd.print("Botao Igual Ante");
										        data_aux = valor_ir_tv[botao_n_ok];
	                                            adress_eeprom = 0;
	                                            if (EEpromWritelong(adress_eeprom, data_aux))
	                                            {
	                                            	lcd.setCursor(0,4);
			   								    	//         1234567890123456   
						    						lcd.print("Grava EEPROM Ok");
	                                            }
	                                            else
	                                            {
	                                            	lcd.setCursor(0,4);
			   								    	//         1234567890123456   
						    						lcd.print("ERRO na EEPROM");
	                                            }
			                                    como[0].dev[0].tec[0].ler_ir[0].dado_ir = data_aux;
			                                }
			                                //Incrementa Botao para Sair do While
			                                botao_n_ok++;
									    }
									    //Se dado gravado for diferente do anterior descarta gravaçao e volta Operacional
									    else									    
									    {
									    	lcd.setCursor(0,4);
			   								    //     1234567890123456   
					    					lcd.print("Botao Difer Ante");
									    	for (int i = 0; i < 1; ++i) //Limpa os Dados 
									    	{
									    		valor_ir_tv[i] = 0;
									    	}
									    	lcd.setCursor(0,4);
			   								    //         1234567890123456   
						    				lcd.print("Dado Errado");
						    				lcd.setCursor(0,4);
			   								    //     1234567890123456   
						    				lcd.print("Grave Novamente");

									    	botao_n_ok = 2;
									    }
									}
									//Primeiro Dado ja foi gravado incrementa botao e pega proximo dado
									else
									{
										lcd.setCursor(0,4);
			   								    // 1234567890123456   
						    			lcd.print("Dado Digital Ok");
										botao_n_ok++;
									    IRRecv.resume(); // Recebe o Proximo Valor do Buffer
									}
								}
								IRRecv.resume(); // Recebe o Proximo Valor do Buffer    
					    }
					}
                    state = kOperacional;
				break;

				case 1:
				//Enquanto nao for Gravado 2 vezes o dado IR fica na funcao
					//teste = 0;
					while (botao_n_ok != 2)
					{
						if (envio == 0)
						{
							lcd.setCursor(0,3);
						//             1234567890123456   
						    lcd.print("Botao CH+ da TV");
							envio++;
						}
                        else if (envio == 2)
                        {
                            lcd.setCursor(0,3);
						//             1234567890123456   
						    lcd.print("Insira Novamente");
                            envio++;
                        }
                        /*** Habilita Leitura do Receptor IR ***/
    					IRRecv.enableIRIn();
    					delay(500);
						if (IRRecv.decode(&ir_results)) //Verifico se Tem Dado 
					    {
					        	//Verifica se Dado é Valido, Se For Grava dado na var valor_ir_tv
					        	if (ir_results.value != value_erro) 
					        	{
							        valor_ir_tv[botao_n_ok] = ir_results.value;
							        envio++;
							        //Verifica se ja foi Gravado alguma tecla caso nao Apenas icrementa botao_n_ok e pega proximo dado
							        if(botao_n_ok > 0)// Se ja tiver dado gravado entra no if 
							        {
								        //Verifica se dado gravado é igual ao Anterior 
								        if ((valor_ir_tv[botao_n_ok]) == (valor_ir_tv[botao_n_ok - 1]))
								        {									        
			                                if (botao_n_ok == 1)
			                                {
										        lcd.setCursor(0,4);
			   								    //         1234567890123456   
						    					lcd.print("Botao Igual Ante");
										        data_aux = valor_ir_tv[botao_n_ok];
	                                            adress_eeprom = 4;
	                                            if (EEpromWritelong(adress_eeprom, data_aux))
	                                            {
	                                            	lcd.setCursor(0,4);
			   								    	//         1234567890123456   
						    						lcd.print("Grava EEPROM Ok");
	                                            }
	                                            else
	                                            {	
	                                            	lcd.setCursor(0,4);
			   								    	//         1234567890123456   
						    						lcd.print("ERRO na EEPROM");
	                                            }
			                                    como[0].dev[0].tec[0].ler_ir[1].dado_ir = data_aux;
			                                }
			                                //Incrementa Botao para Sair do While
			                                botao_n_ok++;
									    }
									    //Se dado gravado for diferente do anterior descarta gravaçao e volta Operacional
									    else									    
									    {
									    	lcd.setCursor(0,4);
			   								    //     1234567890123456   
					    					lcd.print("Botao Difer Ante");
									    	for (int i = 0; i < 1; ++i) //Limpa os Dados 
									    	{
									    		valor_ir_tv[i] = 0;
									    	}
									    	lcd.setCursor(0,4);
			   								    //         1234567890123456   
						    				lcd.print("Dado Errado");
						    				lcd.setCursor(0,4);
			   								    //     1234567890123456   
						    				lcd.print("Grave Novamente");
									    	botao_n_ok = 2;
									    }
									}
									//Primeiro Dado ja foi gravado incrementa botao e pega proximo dado
									else
									{
										lcd.setCursor(0,4);
			   								    // 1234567890123456   
						    			lcd.print("Dado Digital Ok");
										botao_n_ok++;
									    IRRecv.resume(); // Recebe o Proximo Valor do Buffer
									}
								}
								IRRecv.resume(); // Recebe o Proximo Valor do Buffer
					    }
					}
                    state = kOperacional;
				break;
				
				case 2:
				//Enquanto nao for Gravado 2 vezes o dado IR fica na funcao
					//teste = 0;
					while (botao_n_ok != 2)
					{
						if (envio == 0)
						{
							lcd.setCursor(0,3);
						//             1234567890123456   
						    lcd.print("Botao CH- da TV");
							envio++;
						}
                        else if (envio == 2)
                        {
                            lcd.setCursor(0,3);
						//             1234567890123456   
						    lcd.print("Insira Novamente");
                            envio++;
                        }
                        /*** Habilita Leitura do Receptor IR ***/
    					IRRecv.enableIRIn();
    					delay(500);
						if (IRRecv.decode(&ir_results)) //Verifico se Tem Dado 
					    {
					        	//Verifica se Dado é Valido, Se For Grava dado na var valor_ir_tv
					        	if (ir_results.value != value_erro) 
					        	{
							        valor_ir_tv[botao_n_ok] = ir_results.value;
							        envio++;
							        //Verifica se ja foi Gravado alguma tecla caso nao Apenas icrementa botao_n_ok e pega proximo dado
							        if(botao_n_ok > 0)// Se ja tiver dado gravado entra no if 
							        {
								        //Verifica se dado gravado é igual ao Anterior 
								        if ((valor_ir_tv[botao_n_ok]) == (valor_ir_tv[botao_n_ok - 1]))
								        {									        
			                                if (botao_n_ok == 1)
			                                {
			                                    lcd.setCursor(0,4);
			   								    //         1234567890123456   
						    					lcd.print("Botao Igual Ante");
										        data_aux = valor_ir_tv[botao_n_ok];
	                                            adress_eeprom =8;
	                                            if (EEpromWritelong(adress_eeprom, data_aux))
	                                            {
	                                            	lcd.setCursor(0,4);
			   								    	//         1234567890123456   
						    						lcd.print("Grava EEPROM Ok");
	                                            }
	                                            else
	                                            {
	                                            	lcd.setCursor(0,4);
			   								    	//         1234567890123456   
						    						lcd.print("ERRO na EEPROM");	
	                                            }
			                                    como[0].dev[0].tec[0].ler_ir[2].dado_ir = data_aux;
			                                }
			                                //Incrementa Botao para Sair do While
			                                botao_n_ok++;
									    }
									    //Se dado gravado for diferente do anterior descarta gravaçao e volta Operacional
									    else									    
									    {
									    	lcd.setCursor(0,4);
			   								    //     1234567890123456   
					    					lcd.print("Botao Difer Ante");
									    	for (int i = 0; i < 1; ++i) //Limpa os Dados 
									    	{
									    		valor_ir_tv[i] = 0;
									    	}
									    	lcd.setCursor(0,4);
			   								    //         1234567890123456   
						    				lcd.print("Dado Errado");
						    				lcd.setCursor(0,4);
			   								    //     1234567890123456   
						    				lcd.print("Grave Novamente");
									    	botao_n_ok = 2;
									    }
									}
									//Primeiro Dado ja foi gravado incrementa botao e pega proximo dado
									else
									{
										lcd.setCursor(0,4);
			   								    // 1234567890123456   
						    			lcd.print("Dado Digital Ok");
										botao_n_ok++;
									    IRRecv.resume(); // Recebe o Proximo Valor do Buffer
									}
								}
								IRRecv.resume(); // Recebe o Proximo Valor do Buffer   
					    }
					}
                    state = kOperacional;
				break;

				case 3:
				//Enquanto nao for Gravado 2 vezes o dado IR fica na funcao
					//teste = 0;
					while (botao_n_ok != 2)
					{
						if (envio == 0)
						{
							lcd.setCursor(0,3);
						//             1234567890123456   
						    lcd.print("Botao VL+ da TV");
							envio++;
						}
                        else if (envio == 2)
                        {
                            lcd.setCursor(0,3);
						//             1234567890123456   
						    lcd.print("Insira Novamente");
                            envio++;
                        }
                        /*** Habilita Leitura do Receptor IR ***/
    					IRRecv.enableIRIn();
    					delay(500);
						if (IRRecv.decode(&ir_results)) //Verifico se Tem Dado 
					    {
					        	//Verifica se Dado é Valido, Se For Grava dado na var valor_ir_tv
					        	if (ir_results.value != value_erro) 
					        	{
							        valor_ir_tv[botao_n_ok] = ir_results.value;
							        envio++;
							        //Verifica se ja foi Gravado alguma tecla caso nao Apenas icrementa botao_n_ok e pega proximo dado
							        if(botao_n_ok > 0)// Se ja tiver dado gravado entra no if 
							        {
								        //Verifica se dado gravado é igual ao Anterior 
								        if ((valor_ir_tv[botao_n_ok]) == (valor_ir_tv[botao_n_ok - 1]))
								        {									        
			                                if (botao_n_ok == 1)
			                                {
			                                    //Serial.println("Botao Controle Remoto igual ao anterior");
										        lcd.setCursor(0,4);
			   								    //         1234567890123456   
						    					lcd.print("Botao Igual Ante");
										        data_aux = valor_ir_tv[botao_n_ok];
	                                            adress_eeprom = 12;
	                                            if (EEpromWritelong(adress_eeprom, data_aux))
	                                            {
	                                            	lcd.setCursor(0,4);
			   								    	//         1234567890123456   
						    						lcd.print("Grava EEPROM Ok");
	                                            }
	                                            else
	                                            {	
	                                            	lcd.setCursor(0,4);
			   								    	//         1234567890123456   
						    						lcd.print("ERRO na EEPROM");
	                                            }
			                                    como[0].dev[0].tec[0].ler_ir[3].dado_ir = data_aux;
			                                }
			                                //Incrementa Botao para Sair do While
			                                botao_n_ok++;
									    }
									    //Se dado gravado for diferente do anterior descarta gravaçao e volta Operacional
									    else									    
									    {
									    	lcd.setCursor(0,4);
			   								    //     1234567890123456   
					    					lcd.print("Botao Difer Ante");
									    	for (int i = 0; i < 1; ++i) //Limpa os Dados 
									    	{
									    		valor_ir_tv[i] = 0;
									    	}
									    	lcd.setCursor(0,4);
			   								    //         1234567890123456   
						    				lcd.print("Dado Errado");
						    				lcd.setCursor(0,4);
			   								    //     1234567890123456   
						    				lcd.print("Grave Novamente");
									    	botao_n_ok = 2;
									    }
									}
									//Primeiro Dado ja foi gravado incrementa botao e pega proximo dado
									else
									{
										lcd.setCursor(0,4);
			   								    // 1234567890123456   
						    			lcd.print("Dado Digital Ok");
										botao_n_ok++;
									    IRRecv.resume(); // Recebe o Proximo Valor do Buffer
									}
								}
								IRRecv.resume(); // Recebe o Proximo Valor do Buffer    
					    }
					}
                    state = kOperacional;
				break;

				case 4:
				//Enquanto nao for Gravado 2 vezes o dado IR fica na funcao
					//teste = 0;
					while (botao_n_ok != 2)
					{
						if (envio == 0)
						{
							lcd.setCursor(0,3);
						//             1234567890123456   
						    lcd.print("Botao VL- da TV");
							envio++;
						}
                        else if (envio == 2)
                        {
                            lcd.setCursor(0,3);
						//             1234567890123456   
						    lcd.print("Insira Novamente");
                            envio++;
                        }
                        /*** Habilita Leitura do Receptor IR ***/
    					IRRecv.enableIRIn();
    					delay(500);
						if (IRRecv.decode(&ir_results)) //Verifico se Tem Dado 
					    {
					        	//Verifica se Dado é Valido, Se For Grava dado na var valor_ir_tv
					        	if (ir_results.value != value_erro) 
					        	{
							        valor_ir_tv[botao_n_ok] = ir_results.value;
							        envio++;
							        //Verifica se ja foi Gravado alguma tecla caso nao Apenas icrementa botao_n_ok e pega proximo dado
							        if(botao_n_ok > 0)// Se ja tiver dado gravado entra no if 
							        {
								        //Verifica se dado gravado é igual ao Anterior 
								        if ((valor_ir_tv[botao_n_ok]) == (valor_ir_tv[botao_n_ok - 1]))
								        {									        
			                                if (botao_n_ok == 1)
			                                {
			                                    //Serial.println("Botao Controle Remoto igual ao anterior");
			                                    lcd.setCursor(0,4);
			   								    //         1234567890123456   
						    					lcd.print("Botao Igual Ante");
										        data_aux = valor_ir_tv[botao_n_ok];
	                                            adress_eeprom = 16;
	                                            if (EEpromWritelong(adress_eeprom, data_aux))
	                                            {
	                                            	lcd.setCursor(0,4);
			   								    	//         1234567890123456   
						    						lcd.print("Grava EEPROM Ok");
	                                            }
	                                            else
	                                            {
	                                            	lcd.setCursor(0,4);
			   								    	//         1234567890123456   
						    						lcd.print("ERRO na EEPROM");
	                                            }
			                                    como[0].dev[0].tec[0].ler_ir[4].dado_ir = data_aux;
			                                }
			                                //Incrementa Botao para Sair do While
			                                botao_n_ok++;
									    }
									    //Se dado gravado for diferente do anterior descarta gravaçao e volta Operacional
									    else									    
									    {
									    	//Serial.println("Botao Diferente do anterior");
									    	lcd.setCursor(0,4);
			   								    //     1234567890123456   
					    					lcd.print("Botao Difer Ante");
									    	for (int i = 0; i < 1; ++i) //Limpa os Dados 
									    	{
									    		valor_ir_tv[i] = 0;
									    	}
									    	//Serial.println("Dado Errado Grave Novamente");
									    	lcd.setCursor(0,4);
			   								    //         1234567890123456   
						    				lcd.print("Dado Errado");
						    				lcd.setCursor(0,4);
			   								    //     1234567890123456   
						    				lcd.print("Grave Novamente");
									    	botao_n_ok = 2;
									    }
									}
									//Primeiro Dado ja foi gravado incrementa botao e pega proximo dado
									else
									{
										lcd.setCursor(0,4);
			   								    // 1234567890123456   
						    			lcd.print("Dado Digital Ok");
										botao_n_ok++;
									    IRRecv.resume(); // Recebe o Proximo Valor do Buffer
									}
								}
								IRRecv.resume(); // Recebe o Proximo Valor do Buffer
					    }
					}
                    state = kOperacional;
				break;
				default:
				break;
			}
    
}
