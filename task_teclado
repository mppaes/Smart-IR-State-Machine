/****************************************************************************
*                                                  São José dos Campos - SP *
*                                                                           *
* Mateus Pinto Paes                                                         *
* ============================================                              *
*                                                                           *
* Programa: HOME-IR                                                         *
* Projeto: HOME-IR                                                          *
* VersãoGit: N/A                                                             *
*                                                                           *
****************************************************************************/
  
/**
* @ingroup task_displaytft
* @brief   Função que exibe nos display tft as informações
* @param   Nenhum
* @return  
 * @return  
 * 
 * @note Verificado por:
* @note Validado por:
*
* @author  Tec. Mateus P Paes (mppaes@me.com)
* @date 06/mai/2015
*
*/

/*********************************************************************
* testdrawtext
*********************************************************************/
void func_hab_recep (int teste)
{
    int botao_n_ok =0;
    long int data_aux;
    int envio = 0;
    long int value_erro = 0xFFFFFFFF;


    switch (teste)
			{
				//Controle TV
				case 0:
					//Enquanto nao for Gravado 3 vezes o dado IR fica na funcao
					teste = 0;
					while (botao_n_ok != 2)
					{
						if (envio == 0)
						{
							Serial.println("Aperte o Botao Desejado");
							envio++;
						}
                        else if (envio == 2)
                        {
                            Serial.println("Aperte o Botao Desejado");
                            envio++;
                        }
                        /*** Habilita Leitura do Receptor IR ***/
    					IRRecv.enableIRIn();
    					delay(500);
						if (IRRecv.decode(&ir_results)) //Verifico se Tem Dado 
					    {
					        	//Verifica se Dado é Valido, Se For Grava dado na var valor_ir_tv
					        	if (ir_results.value != value_erro) 
					        	{
						        	Serial.print("Sinal Infra Red Digitalizado - Hex 0x: ");
							        Serial.println(ir_results.value, HEX);
							        valor_ir_tv[botao_n_ok] = ir_results.value;
							        Serial.print("Sinal da Var valor_ir_tv - Hex 0x: ");
							        Serial.println(valor_ir_tv[botao_n_ok], HEX);
							        envio++;
							        //Verifica se ja foi Gravado alguma tecla caso nao Apenas icrementa botao_n_ok e pega proximo dado
							        if(botao_n_ok > 0)// Se ja tiver dado gravado entra no if 
							        {
								        //Verifica se dado gravado é igual ao Anterior 
								        if ((valor_ir_tv[botao_n_ok]) == (valor_ir_tv[botao_n_ok - 1]))
								        {									        
			                                if (botao_n_ok == 1)
			                                {
			                                    Serial.println("Botao Igual ao anterior");
										        data_aux = valor_ir_tv[botao_n_ok];
										        Serial.print("Sinal do DATA AUX:");
	                                            Serial.println(data_aux, HEX);
			                                    como[0].dev[0].tec[0].ler_ir[0].dado_ir = data_aux;
			                                    //Serial.print("Sinal do Struct:");
	                                            //Serial.println(como[0].dev[0].tec[0].ler_ir[0].dado_ir, HEX);
	                                            IRRecv.resume(); // Recebe o Proximo Valor do Buffer
			                                }
			                                botao_n_ok++;
									    }
									    //Se dado gravado for diferente do anterior descarta gravaçao e volta Operacional
									    else									    
									    {
									    	Serial.println("Botao Diferente do anterior");
									    	for (int i = 0; i < 1; ++i) //Limpa os Dados 
									    	{
									    		valor_ir_tv[i] = 0;
									    	}
									    	Serial.println("Dado Errado Grave Novamente");
									    	botao_n_ok = 2;
									    }
									}
									//Primeiro Dado ja foi gravado incrementa botao e pega proximo dado
									else
									{
										Serial.println("Botao 0 Gravado incrementa botao");
										botao_n_ok++;
									    IRRecv.resume(); // Recebe o Proximo Valor do Buffer
									}
								}
								IRRecv.resume(); // Recebe o Proximo Valor do Buffer
							    
					    }
					}
					Serial.print("Sinal do Struct:");
	                Serial.println(como[0].dev[0].tec[0].ler_ir[0].dado_ir, HEX);
                    state = kOperacional;
				break;

				case 1:
				//Enquanto nao for Gravado 3 vezes o dado IR fica na funcao
					teste = 0;
					while (botao_n_ok != 2)
					{
						if (envio == 0)
						{
							Serial.println("Aperte o Botao Desejado");
							envio++;
						}
                        else if (envio == 2)
                        {
                            Serial.println("Aperte o Botao Desejado");
                            envio++;
                        }
                        /*** Habilita Leitura do Receptor IR ***/
    					IRRecv.enableIRIn();
    					delay(500);
						if (IRRecv.decode(&ir_results)) //Verifico se Tem Dado 
					    {
					        	//Verifica se Dado é Valido, Se For Grava dado na var valor_ir_tv
					        	if (ir_results.value != value_erro) 
					        	{
						        	Serial.print("Sinal Infra Red Digitalizado - Hex 0x: ");
							        Serial.println(ir_results.value, HEX);
							        valor_ir_tv[botao_n_ok] = ir_results.value;
							        Serial.print("Sinal da Var valor_ir_tv - Hex 0x: ");
							        Serial.println(valor_ir_tv[botao_n_ok], HEX);
							        envio++;
							        //Verifica se ja foi Gravado alguma tecla caso nao Apenas icrementa botao_n_ok e pega proximo dado
							        if(botao_n_ok > 0)// Se ja tiver dado gravado entra no if 
							        {
								        //Verifica se dado gravado é igual ao Anterior 
								        if ((valor_ir_tv[botao_n_ok]) == (valor_ir_tv[botao_n_ok - 1]))
								        {									        
			                                if (botao_n_ok == 1)
			                                {
			                                    Serial.println("Botao Igual ao anterior");
										        data_aux = valor_ir_tv[botao_n_ok];
										        Serial.print("Sinal do DATA AUX:");
	                                            Serial.println(data_aux, HEX);
			                                    como[0].dev[0].tec[0].ler_ir[1].dado_ir = data_aux;
			                                    //Serial.print("Sinal do Struct:");
	                                            //Serial.println(como[0].dev[0].tec[0].ler_ir[0].dado_ir, HEX);
	                                            IRRecv.resume(); // Recebe o Proximo Valor do Buffer
			                                }
			                                botao_n_ok++;
									    }
									    //Se dado gravado for diferente do anterior descarta gravaçao e volta Operacional
									    else									    
									    {
									    	Serial.println("Botao Diferente do anterior");
									    	for (int i = 0; i < 1; ++i) //Limpa os Dados 
									    	{
									    		valor_ir_tv[i] = 0;
									    	}
									    	Serial.println("Dado Errado Grave Novamente");
									    	botao_n_ok = 2;
									    }
									}
									//Primeiro Dado ja foi gravado incrementa botao e pega proximo dado
									else
									{
										Serial.println("Botao 0 Gravado incrementa botao");
										botao_n_ok++;
									    IRRecv.resume(); // Recebe o Proximo Valor do Buffer
									}
								}
								IRRecv.resume(); // Recebe o Proximo Valor do Buffer
							    
					    }
					}
					Serial.print("Sinal do Struct:");
	                Serial.println(como[0].dev[0].tec[0].ler_ir[1].dado_ir, HEX);
                    state = kOperacional;
				break;
				
				default:
				break;
			}
    
}























